using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using System.ComponentModel;
using System.Text;
using System.Text.RegularExpressions;
using YoutubeExplode;
using YoutubeExplode.Common;
using YoutubeExplode.Exceptions;

namespace SemanticKernelFunctionCaller.Infrastructure.Plugins;

/// <summary>
/// Semantic Kernel plugin for analyzing YouTube videos through transcript analysis.
/// Enables natural language Q&A about video content without watching the entire video.
/// </summary>
public class YouTubeAnalysisPlugin(
    IMemoryCache cache,
    ILogger<YouTubeAnalysisPlugin> logger)
{
    private readonly YoutubeClient _youtube = new YoutubeClient();

    // Cache settings
    private const int MaxCachedTranscripts = 50;
    private static readonly TimeSpan CacheDuration = TimeSpan.FromHours(2);

    // Chunking settings for long videos
    private const int MaxWordsPerChunk = 2000;
    private const int ChunkOverlapWords = 100;

    /// <summary>
    /// Loads a YouTube video's full transcript for analysis.
    /// Best for short videos (under 15 minutes) or when you need complete context.
    /// </summary>
    [KernelFunction]
    [Description("Load the complete transcript of a YouTube video. Use this when the user provides a YouTube URL and wants to ask questions about the video content.")]
    public async Task<string> LoadVideoTranscript(
        [Description("YouTube video URL (e.g., https://youtube.com/watch?v=VIDEO_ID or https://youtu.be/VIDEO_ID)")]
        string videoUrl)
    {
        try
        {
            logger.LogInformation("Loading transcript for video: {VideoUrl}", videoUrl);

            // Extract video ID
            var videoId = ExtractVideoId(videoUrl);
            if (string.IsNullOrEmpty(videoId))
            {
                return "‚ùå Invalid YouTube URL. Please provide a valid YouTube video link.";
            }

            // Check cache first
            var cacheKey = $"transcript_{videoId}";
            if (cache.TryGetValue(cacheKey, out string? cachedTranscript) && cachedTranscript != null)
            {
                logger.LogInformation("Returning cached transcript for video: {VideoId}", videoId);
                return cachedTranscript;
            }

            // Fetch video metadata
            var video = await _youtube.Videos.GetAsync(videoId);

            // Fetch transcript
            var trackManifest = await _youtube.Videos.ClosedCaptions.GetManifestAsync(videoId);

            // Try to get the best available caption track
            var trackInfo = trackManifest.TryGetByLanguage("en");

            if (trackInfo == null)
            {
                // Fallback to any English variant
                trackInfo = trackManifest.Tracks
                    .FirstOrDefault(t => t.Language.Code.StartsWith("en"));
            }

            if (trackInfo == null)
            {
                // Last resort: get any auto-generated or manual track
                trackInfo = trackManifest.Tracks
                    .OrderByDescending(t => !t.IsAutoGenerated) // Prefer manual captions
                    .FirstOrDefault();
            }

            if (trackInfo == null)
            {
                return $"‚ùå No captions available for this video.\n\n" +
                       $"Video: {video.Title}\n" +
                       $"Channel: {video.Author.ChannelTitle}\n\n" +
                       $"The video creator has not enabled captions.";
            }

            var track = await _youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

            // Format transcript with timestamps
            var transcriptBuilder = new StringBuilder();
            transcriptBuilder.AppendLine($"üìπ VIDEO INFORMATION");
            transcriptBuilder.AppendLine($"Title: {video.Title}");
            transcriptBuilder.AppendLine($"Channel: {video.Author.ChannelTitle}");
            transcriptBuilder.AppendLine($"Duration: {FormatDuration(video.Duration)}");
            transcriptBuilder.AppendLine($"Published: {video.UploadDate:MMM dd, yyyy}");
            transcriptBuilder.AppendLine($"Views: {video.Engagement.ViewCount:N0}");
            transcriptBuilder.AppendLine();
            transcriptBuilder.AppendLine("üìù TRANSCRIPT:");
            transcriptBuilder.AppendLine("---");

            foreach (var caption in track.Captions)
            {
                var timestamp = FormatTimestamp(caption.Offset);
                transcriptBuilder.AppendLine($"[{timestamp}] {caption.Text}");
            }

            var result = transcriptBuilder.ToString();

            // Cache the result
            var cacheOptions = new MemoryCacheEntryOptions()
                .SetSize(1)
                .SetSlidingExpiration(CacheDuration);

            cache.Set(cacheKey, result, cacheOptions);

            logger.LogInformation("Successfully loaded transcript for video: {Title}", video.Title);

            return result;
        }
        catch (VideoUnavailableException)
        {
            logger.LogWarning("Video unavailable: {VideoUrl}", videoUrl);
            return "‚ùå Video is unavailable. It may be private, deleted, age-restricted, or region-locked.";
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error loading video transcript: {VideoUrl}", videoUrl);
            return $"‚ùå Error loading video: {ex.Message}";
        }
    }

    /// <summary>
    /// Searches for specific topics within a video transcript.
    /// Best for long videos where you need specific information.
    /// </summary>
    [KernelFunction]
    [Description("Search for specific topics or keywords within a YouTube video transcript. Use this for long videos when you need to find specific information without loading the entire transcript.")]
    public async Task<string> SearchVideoContent(
        [Description("YouTube video URL")] string videoUrl,
        [Description("Topic, keyword, or question to search for in the video")] string searchQuery)
    {
        try
        {
            logger.LogInformation("Searching video {VideoUrl} for: {Query}", videoUrl, searchQuery);

            var videoId = ExtractVideoId(videoUrl);
            if (string.IsNullOrEmpty(videoId))
            {
                return "‚ùå Invalid YouTube URL.";
            }

            // Get full transcript
            var fullTranscript = await GetRawTranscriptAsync(videoId);
            if (fullTranscript.StartsWith("‚ùå"))
            {
                return fullTranscript; // Return error message
            }

            // Split into chunks and find most relevant
            var chunks = CreateTranscriptChunks(fullTranscript);
            var relevantChunks = FindRelevantChunks(chunks, searchQuery);

            if (!relevantChunks.Any())
            {
                return $"üîç No relevant content found for '{searchQuery}' in this video.";
            }

            var result = new StringBuilder();
            result.AppendLine($"üîç Found {relevantChunks.Count} relevant sections about '{searchQuery}':");
            result.AppendLine();

            foreach (var chunk in relevantChunks.Take(3)) // Top 3 most relevant
            {
                result.AppendLine("---");
                result.AppendLine(chunk);
                result.AppendLine();
            }

            return result.ToString();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error searching video content");
            return $"‚ùå Error searching video: {ex.Message}";
        }
    }

    /// <summary>
    /// Gets metadata about a YouTube video without loading the full transcript.
    /// </summary>
    [KernelFunction]
    [Description("Get information about a YouTube video (title, channel, duration, views, description) without loading the transcript. Use this when the user asks about video details.")]
    public async Task<string> GetVideoMetadata(
        [Description("YouTube video URL")] string videoUrl)
    {
        try
        {
            var videoId = ExtractVideoId(videoUrl);
            if (string.IsNullOrEmpty(videoId))
            {
                return "‚ùå Invalid YouTube URL.";
            }

            var cacheKey = $"metadata_{videoId}";
            if (cache.TryGetValue(cacheKey, out string? cachedMetadata) && cachedMetadata != null)
            {
                return cachedMetadata;
            }

            var video = await _youtube.Videos.GetAsync(videoId);

            var result = new StringBuilder();
            result.AppendLine("üìπ VIDEO INFORMATION");
            result.AppendLine($"Title: {video.Title}");
            result.AppendLine($"Channel: {video.Author.ChannelTitle}");
            result.AppendLine($"Duration: {FormatDuration(video.Duration)}");
            result.AppendLine($"Published: {video.UploadDate:MMMM dd, yyyy}");
            result.AppendLine($"Views: {video.Engagement.ViewCount:N0}");
            result.AppendLine($"Likes: {video.Engagement.LikeCount:N0}");
            result.AppendLine();

            if (!string.IsNullOrWhiteSpace(video.Description))
            {
                result.AppendLine("üìÑ DESCRIPTION:");
                var description = video.Description.Length > 500
                    ? video.Description.Substring(0, 500) + "..."
                    : video.Description;
                result.AppendLine(description);
            }

            var resultString = result.ToString();

            var cacheOptions = new MemoryCacheEntryOptions()
                .SetSize(1)
                .SetSlidingExpiration(CacheDuration);

            cache.Set(cacheKey, resultString, cacheOptions);

            return resultString;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error fetching video metadata");
            return $"‚ùå Error fetching video metadata: {ex.Message}";
        }
    }

    private string ExtractVideoId(string videoUrl)
    {
        try
        {
            // Handle various YouTube URL formats
            var patterns = new[]
            {
                @"youtube\.com/watch\?v=([^&]+)",
                @"youtu\.be/([^?]+)",
                @"youtube\.com/embed/([^?]+)",
                @"youtube\.com/v/([^?]+)"
            };

            foreach (var pattern in patterns)
            {
                var match = Regex.Match(videoUrl, pattern);
                if (match.Success)
                {
                    return match.Groups[1].Value;
                }
            }

            // If it's already just a video ID
            if (Regex.IsMatch(videoUrl, @"^[a-zA-Z0-9_-]{11}$"))
            {
                return videoUrl;
            }

            return string.Empty;
        }
        catch
        {
            return string.Empty;
        }
    }

    private async Task<string> GetRawTranscriptAsync(string videoId)
    {
        var cacheKey = $"raw_transcript_{videoId}";
        if (cache.TryGetValue(cacheKey, out string? cached) && cached != null)
        {
            return cached;
        }

        try
        {
            var video = await _youtube.Videos.GetAsync(videoId);
            var trackManifest = await _youtube.Videos.ClosedCaptions.GetManifestAsync(videoId);

            var trackInfo = trackManifest.TryGetByLanguage("en")
                         ?? trackManifest.TryGetByLanguage("en-US")
                         ?? trackManifest.Tracks.FirstOrDefault(); // Add .Tracks here

            if (trackInfo == null)
            {
                return "‚ùå No captions available.";
            }

            var track = await _youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

            var transcriptBuilder = new StringBuilder();
            transcriptBuilder.AppendLine($"Title: {video.Title}");
            transcriptBuilder.AppendLine($"Channel: {video.Author.ChannelTitle}");
            transcriptBuilder.AppendLine();

            foreach (var caption in track.Captions)
            {
                var timestamp = FormatTimestamp(caption.Offset);
                transcriptBuilder.AppendLine($"[{timestamp}] {caption.Text}");
            }

            var result = transcriptBuilder.ToString();

            var cacheOptions = new MemoryCacheEntryOptions()
                .SetSize(1)
                .SetSlidingExpiration(CacheDuration);

            cache.Set(cacheKey, result, cacheOptions);

            return result;
        }
        catch
        {
            return "‚ùå Error loading transcript.";
        }
    }

    private List<string> CreateTranscriptChunks(string transcript)
    {
        var chunks = new List<string>();
        var lines = transcript.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var currentChunk = new StringBuilder();
        var wordCount = 0;

        foreach (var line in lines)
        {
            var lineWords = line.Split(' ').Length;

            if (wordCount + lineWords > MaxWordsPerChunk && wordCount > 0)
            {
                chunks.Add(currentChunk.ToString());

                // Start new chunk with overlap
                var overlapLines = currentChunk.ToString()
                    .Split('\n')
                    .TakeLast(5); // Keep last 5 lines for context

                currentChunk.Clear();
                currentChunk.AppendLine(string.Join("\n", overlapLines));
                wordCount = overlapLines.Sum(l => l.Split(' ').Length);
            }

            currentChunk.AppendLine(line);
            wordCount += lineWords;
        }

        if (currentChunk.Length > 0)
        {
            chunks.Add(currentChunk.ToString());
        }

        return chunks;
    }

    private List<string> FindRelevantChunks(List<string> chunks, string searchQuery)
    {
        // Simple keyword-based relevance scoring
        var keywords = searchQuery.ToLower()
            .Split(' ', StringSplitOptions.RemoveEmptyEntries)
            .Where(w => w.Length > 3) // Ignore short words
            .ToList();

        var scoredChunks = chunks.Select(chunk =>
        {
            var chunkLower = chunk.ToLower();
            var score = keywords.Sum(keyword =>
                Regex.Matches(chunkLower, Regex.Escape(keyword)).Count);

            return new { Chunk = chunk, Score = score };
        })
        .Where(x => x.Score > 0)
        .OrderByDescending(x => x.Score)
        .Select(x => x.Chunk)
        .ToList();

        return scoredChunks;
    }

    private string FormatDuration(TimeSpan? duration)
    {
        if (duration == null) return "Unknown";

        var ts = duration.Value;
        if (ts.TotalHours >= 1)
            return $"{(int)ts.TotalHours}:{ts.Minutes:D2}:{ts.Seconds:D2}";
        else
            return $"{ts.Minutes}:{ts.Seconds:D2}";
    }

    private string FormatTimestamp(TimeSpan offset)
    {
        if (offset.TotalHours >= 1)
            return $"{(int)offset.TotalHours}:{offset.Minutes:D2}:{offset.Seconds:D2}";
        else
            return $"{offset.Minutes}:{offset.Seconds:D2}";
    }
}